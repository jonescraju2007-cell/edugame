{
  "meta": {
    "title": "World 5: Data Structures",
    "intro": "Lists, tuples, dicts, sets; key methods & patterns; stacks/queues, heaps, Counter/defaultdict; copying & aliasing; sorting & keys; hashing & immutability; nested structures."
  },
  "lessons": {
    "list": {
      "title": "Lists (mutable sequences)",
      "html": "<p>Ordered, mutable. Common ops: index, slice, append, extend, insert, pop, remove.</p><pre><code>L = [1,2]\nL.append(3)      # [1,2,3]\nL.extend([4,5])  # [1,2,3,4,5]\nL.pop()          # 5</code></pre>"
    },
    "tuple": {
      "title": "Tuples (immutable sequences)",
      "html": "<p>Ordered, immutable. Good for fixed records / dict keys.</p><pre><code>t = (1,2)\none = (1,)</code></pre>"
    },
    "set": {
      "title": "Sets (unique items)",
      "html": "<p>Unordered, unique. Ops: union <code>|</code>, intersection <code>&amp;</code>, difference <code>-</code>, symmetric difference <code>^</code>.</p><pre><code>s = {1,2,2}\ns == {1,2}\n{1,2} | {2,3}  # {1,2,3}</code></pre>"
    },
    "dict": {
      "title": "Dictionaries (key→value)",
      "html": "<p>Mapping type. Views: <code>keys()</code>, <code>values()</code>, <code>items()</code>.</p><pre><code>d = {'a':1}\nd['b']=2\nfor k,v in d.items():\n    ...</code></pre>"
    },
    "methods_list": {
      "title": "Useful list methods",
      "html": "<pre><code>L.append(x)  # add at end\nL.extend(xs) # add many\nL.insert(i,x)\nL.pop([i])\nL.remove(x)  # by value (first)\nL.index(x)\nL.count(x)\nL.sort(key=..., reverse=...)\n</code></pre>"
    },
    "methods_dict": {
      "title": "Useful dict methods",
      "html": "<pre><code>d.get(k, default)\nd.setdefault(k, default)\nd.update(other)\nd.pop(k[, default])\nd.popitem()</code></pre>"
    },
    "methods_set": {
      "title": "Useful set methods",
      "html": "<pre><code>s.add(x)\ns.remove(x)   # KeyError if absent\ns.discard(x)  # safe\ns.pop()       # arbitrary\ns.update(t)\ns.clear()</code></pre>"
    },
    "slicing": {
      "title": "Slicing",
      "html": "<p><code>seq[start:stop:step]</code> returns a new sequence (shallow copy of slice).</p><pre><code>L[1:4]\nL[::-1]  # reversed copy</code></pre>"
    },
    "copy": {
      "title": "Copying",
      "html": "<p>Shallow copy copies the outer container; nested objects are shared. Deep copy clones recursively.</p><pre><code>import copy\nsh = L.copy()       # or L[:]\ndp = copy.deepcopy(L)</code></pre>"
    },
    "aliasing": {
      "title": "Aliasing (same object)",
      "html": "<p>Multiple names can reference the same object; mutating via one affects the other.</p><pre><code>A = [1]\nB = A\nB.append(2)  # A is [1,2] too</code></pre>"
    },
    "sorting": {
      "title": "Sorting & keys",
      "html": "<p><code>list.sort()</code> sorts in place; <code>sorted(iterable)</code> returns a new list; both accept <code>key</code> and <code>reverse</code>.</p><pre><code>names.sort(key=len)\nnums_sorted = sorted(nums, reverse=True)</code></pre>"
    },
    "dict_views": {
      "title": "Dictionary views",
      "html": "<p><code>keys()</code>, <code>values()</code>, <code>items()</code> are dynamic views reflecting changes.</p>"
    },
    "membership": {
      "title": "Membership",
      "html": "<p><code>in</code> checks elements (lists/tuples/sets) or keys (dicts).</p>"
    },
    "hashing": {
      "title": "Hashability",
      "html": "<p>Set/dict keys must be hashable (immutable). Lists are unhashable; tuples are hashable if their items are hashable.</p>"
    },
    "order": {
      "title": "Insertion order",
      "html": "<p>Python 3.7+ preserves dict insertion order as language guarantee.</p>"
    },
    "stack_queue": {
      "title": "Stack & Queue patterns",
      "html": "<p>Use lists as stacks (<code>append</code>/<code>pop</code>); prefer <code>collections.deque</code> for queues (fast appends/pops both ends).</p>"
    },
    "deque": {
      "title": "deque",
      "html": "<p>Double-ended queue with O(1) append/pop from both ends.</p><pre><code>from collections import deque\nq = deque([1,2])\nq.append(3); q.popleft()</code></pre>"
    },
    "heap": {
      "title": "heapq (min-heap)",
      "html": "<p>Binary heap for priority queues.</p><pre><code>import heapq\nh=[]\nheapq.heappush(h, 5)\nheapq.heappush(h, 1)\nheapq.heappop(h)  # 1</code></pre>"
    },
    "counter": {
      "title": "collections.Counter",
      "html": "<p>Counts hashable items.</p><pre><code>from collections import Counter\nc = Counter('banana')\nc.most_common(1)</code></pre>"
    },
    "defaultdict": {
      "title": "collections.defaultdict",
      "html": "<p>Provides default values for missing keys.</p><pre><code>from collections import defaultdict\ndd = defaultdict(list)\ndd['a'].append(1)</code></pre>"
    },
    "nested": {
      "title": "Nested structures",
      "html": "<p>Combine containers: list of dicts, dict of lists, etc.</p><pre><code>students = [{'name':'A','marks':[10,9]}]</code></pre>"
    },
    "unpacking": {
      "title": "Unpacking",
      "html": "<p>Split sequences and dictionaries into names.</p><pre><code>a, b = (1,2)\nfirst, *rest = [1,2,3,4]</code></pre>"
    },
    "iteration": {
      "title": "Iteration patterns",
      "html": "<p>Use <code>for</code>, <code>enumerate</code>, <code>zip</code>, <code>items()</code> for clean traversal.</p>"
    }
  },
  "questions": {
    "simple": [
      { "id": "w5-s-01", "type": "mcq", "topic": "list", "question": "Create a list literal of 1,2,3:", "options": ["(1,2,3)", "[1,2,3]", "{1,2,3}"], "answer": "[1,2,3]", "feedback": { "correct": "✅ [] makes a list.", "wrong": "❌ () is tuple; {} is set/dict." } },
      { "id": "w5-s-02", "type": "truefalse", "topic": "tuple", "question": "(1,) is a one-item tuple.", "answer": "True", "feedback": { "correct": "✅ Trailing comma required.", "wrong": "❌ (1) is just 1." } },
      { "id": "w5-s-03", "type": "mcq", "topic": "set", "question": "Which removes duplicates?", "options": ["list", "set", "tuple"], "answer": "set", "feedback": { "correct": "✅ Sets store unique items.", "wrong": "❌ Only sets deduplicate." } },
      { "id": "w5-s-04", "type": "fill", "topic": "dict", "question": "Make a dict mapping 'a'→1:", "answer": "{'a':1}", "feedback": { "correct": "✅ {'key': value}.", "wrong": "❌ Quote the key." } },
      { "id": "w5-s-05", "type": "mcq", "topic": "methods_list", "question": "Remove last element of L:", "options": ["L.pop()", "L.remove()", "del L"], "answer": "L.pop()", "feedback": { "correct": "✅ pop removes last by default.", "wrong": "❌ remove needs the value." } },
      { "id": "w5-s-06", "type": "fill", "topic": "methods_dict", "question": "Get value for key 'k' with default 0:", "answer": "d.get('k', 0)", "feedback": { "correct": "✅ get handles missing keys.", "wrong": "❌ Use get(key, default)." } },
      { "id": "w5-s-07", "type": "truefalse", "topic": "methods_set", "question": "set.discard(x) raises KeyError if x is missing.", "answer": "False", "feedback": { "correct": "✅ discard is safe; remove raises.", "wrong": "❌ discard never errors." } },
      { "id": "w5-s-08", "type": "fill", "topic": "slicing", "question": "Reverse list L using slicing:", "answer": "L[::-1]", "feedback": { "correct": "✅ step -1 makes reversed copy.", "wrong": "❌ Use L[::-1]." } },
      { "id": "w5-s-09", "type": "mcq", "topic": "copy", "question": "Which makes a shallow copy of list L?", "options": ["L2 = L", "L2 = L.copy()", "L2 = L"], "answer": "L2 = L.copy()", "feedback": { "correct": "✅ .copy() or L[:].", "wrong": "❌ L2=L aliases the same object." } },
      { "id": "w5-s-10", "type": "truefalse", "topic": "aliasing", "question": "If A and B reference the same list, mutating B affects A.", "answer": "True", "feedback": { "correct": "✅ Aliases share storage.", "wrong": "❌ Same object, shared change." } },
      { "id": "w5-s-11", "type": "mcq", "topic": "sorting", "question": "Sort strings by length:", "options": ["names.sort(len)", "names.sort(key=len)", "names.sort(by=len)"], "answer": "names.sort(key=len)", "feedback": { "correct": "✅ Use key= function.", "wrong": "❌ Provide key callable." } },
      { "id": "w5-s-12", "type": "fill", "topic": "dict_views", "question": "Iterate key and value of dict d:", "answer": "for k, v in d.items():", "feedback": { "correct": "✅ items() gives pairs.", "wrong": "❌ Use .items()." } },
      { "id": "w5-s-13", "type": "truefalse", "topic": "membership", "question": "'x' in {'x':1} checks keys and is True.", "answer": "True", "feedback": { "correct": "✅ Membership on dict checks keys.", "wrong": "❌ It doesn't scan values by default." } },
      { "id": "w5-s-14", "type": "mcq", "topic": "hashing", "question": "Which can be a dict key?", "options": ["[1,2]", "(1,2)", "{1,2}"], "answer": "(1,2)", "feedback": { "correct": "✅ Tuple is hashable (if items are).", "wrong": "❌ Lists/sets are unhashable." } },
      { "id": "w5-s-15", "type": "fill", "topic": "order", "question": "Since Python 3.7+, dict preserves ____ order.", "answer": "insertion", "feedback": { "correct": "✅ Insertion order preserved.", "wrong": "❌ It's insertion order." } },
      { "id": "w5-s-16", "type": "mcq", "topic": "stack_queue", "question": "Use list as a stack by:", "options": ["append/pop", "insert/remove", "shift/unshift"], "answer": "append/pop", "feedback": { "correct": "✅ LIFO via append/pop().", "wrong": "❌ insert/remove not ideal here." } },
      { "id": "w5-s-17", "type": "mcq", "topic": "deque", "question": "Fast FIFO queue structure:", "options": ["list", "deque", "tuple"], "answer": "deque", "feedback": { "correct": "✅ deque popleft() is O(1).", "wrong": "❌ list.pop(0) is O(n)." } },
      { "id": "w5-s-18", "type": "fill", "topic": "heap", "question": "Push x into min-heap h (heapq):", "answer": "heapq.heappush(h, x)", "feedback": { "correct": "✅ heappush adds element.", "wrong": "❌ Use heapq methods." } },
      { "id": "w5-s-19", "type": "mcq", "topic": "counter", "question": "Counter('aba').most_common(1) returns:", "options": ["[('a',2)]", "[('b',2)]", "[('a',1)]"], "answer": "[('a',2)]", "feedback": { "correct": "✅ 'a' occurs twice.", "wrong": "❌ Count frequencies carefully." } },
      { "id": "w5-s-20", "type": "truefalse", "topic": "defaultdict", "question": "defaultdict(list) lets you append to missing keys without checks.", "answer": "True", "feedback": { "correct": "✅ It auto-creates list.", "wrong": "❌ That's the point of defaultdict." } },
      { "id": "w5-s-21", "type": "fill", "topic": "nested", "question": "Access 'math' from {'name':'A','marks':{'math':90}}:", "answer": "d['marks']['math']", "feedback": { "correct": "✅ Index into nested dict.", "wrong": "❌ Access inner mapping." } },
      { "id": "w5-s-22", "type": "truefalse", "topic": "tuple", "question": "Tuples can contain lists.", "answer": "True", "feedback": { "correct": "✅ Contents may be mutable; tuple itself is immutable.", "wrong": "❌ Tuple immutability doesn't restrict members' mutability." } },
      { "id": "w5-s-23", "type": "mcq", "topic": "methods_set", "question": "Compute symmetric difference:", "options": ["a^b", "a|b", "a&b"], "answer": "a^b", "feedback": { "correct": "✅ ^ is symmetric diff.", "wrong": "❌ | union, & intersection." } },
      { "id": "w5-s-24", "type": "fill", "topic": "unpacking", "question": "Unpack first into a and rest into r from L:", "answer": "a, *r = L", "feedback": { "correct": "✅ Star captures the rest.", "wrong": "❌ Use star in assignment." } },
      { "id": "w5-s-25", "type": "mcq", "topic": "iteration", "question": "Iterate keys with indexes:", "options": ["for i,k in enumerate(d.keys()):", "for (i,k) of d:", "foreach (i,k) in d"], "answer": "for i,k in enumerate(d.keys()):", "feedback": { "correct": "✅ enumerate over keys.", "wrong": "❌ Only the first is Python." } }
    ],
    "medium": [
      { "id": "w5-m-01", "type": "fill", "topic": "methods_list", "question": "Insert x at index 2 of L:", "answer": "L.insert(2, x)", "feedback": { "correct": "✅ insert(i, x).", "wrong": "❌ Provide index then value." } },
      { "id": "w5-m-02", "type": "mcq", "topic": "methods_dict", "question": "Safely get & set default list at key 'k' then append 1:", "options": ["d['k'].append(1)", "d.setdefault('k', []).append(1)", "d.update({'k':[1]})"], "answer": "d.setdefault('k', []).append(1)", "feedback": { "correct": "✅ setdefault returns the value.", "wrong": "❌ d['k'] may KeyError." } },
      { "id": "w5-m-03", "type": "fill", "topic": "methods_set", "question": "Remove x from set s if present (no error):", "answer": "s.discard(x)", "feedback": { "correct": "✅ discard is safe.", "wrong": "❌ remove may raise KeyError." } },
      { "id": "w5-m-04", "type": "mcq", "topic": "slicing", "question": "Which creates a shallow copy of list L?", "options": ["L[:]", "list(L)", "both"], "answer": "both", "feedback": { "correct": "✅ Both are shallow copies.", "wrong": "❌ They copy only the outer list." } },
      { "id": "w5-m-05", "type": "fill", "topic": "copy", "question": "Deep-copy nested list L:", "answer": "copy.deepcopy(L)", "feedback": { "correct": "✅ Use deepcopy for nested structures.", "wrong": "❌ Shallow copy shares inner lists." } },
      { "id": "w5-m-06", "type": "mcq", "topic": "aliasing", "question": "Which ensures B is an independent copy of A (flat list)?", "options": ["B = A", "B = A.copy()", "B = A; A = []"], "answer": "B = A.copy()", "feedback": { "correct": "✅ Copies outer list.", "wrong": "❌ B=A aliases the same list." } },
      { "id": "w5-m-07", "type": "fill", "topic": "sorting", "question": "Get a new list sorted descending from nums:", "answer": "sorted(nums, reverse=True)", "feedback": { "correct": "✅ sorted returns new list.", "wrong": "❌ Use reverse=True." } },
      { "id": "w5-m-08", "type": "mcq", "topic": "dict_views", "question": "Which reflects live dict changes?", "options": ["list(d.keys())", "d.keys()", "copy(d).keys()"], "answer": "d.keys()", "feedback": { "correct": "✅ Views are dynamic.", "wrong": "❌ list(...) makes a snapshot." } },
      { "id": "w5-m-09", "type": "fill", "topic": "membership", "question": "Check 3 is in set s:", "answer": "3 in s", "feedback": { "correct": "✅ in checks membership.", "wrong": "❌ Use in with sets." } },
      { "id": "w5-m-10", "type": "debug", "topic": "hashing", "question": "Why is {[1,2]: 'x'} invalid?", "options": ["Key must be str", "Lists are unhashable", "Dicts cannot be nested"], "answer": "Lists are unhashable", "feedback": { "correct": "✅ Keys must be hashable.", "wrong": "❌ You can nest dicts; keys just need hashing." } },
      { "id": "w5-m-11", "type": "fill", "topic": "stack_queue", "question": "Use list as stack to push x then pop to y:", "answer": "stack.append(x)\ny = stack.pop()", "feedback": { "correct": "✅ append/pop pair.", "wrong": "❌ Use list methods for LIFO." } },
      { "id": "w5-m-12", "type": "fill", "topic": "deque", "question": "Create deque q from [1,2] then pop left:", "answer": "from collections import deque\nq = deque([1,2])\nq.popleft()", "feedback": { "correct": "✅ deque + popleft().", "wrong": "❌ Import deque and call popleft." } },
      { "id": "w5-m-13", "type": "fill", "topic": "heap", "question": "Pop smallest item from heap h:", "answer": "heapq.heappop(h)", "feedback": { "correct": "✅ heappop returns min.", "wrong": "❌ Use heapq.heappop." } },
      { "id": "w5-m-14", "type": "mcq", "topic": "counter", "question": "Which builds a Counter of list L?", "options": ["Counter(L)", "Counter.fromkeys(L)", "dict(L)"], "answer": "Counter(L)", "feedback": { "correct": "✅ Counter counts items.", "wrong": "❌ fromkeys makes keys with same value." } },
      { "id": "w5-m-15", "type": "fill", "topic": "defaultdict", "question": "Defaultdict of int for counts:", "answer": "from collections import defaultdict\nd = defaultdict(int)", "feedback": { "correct": "✅ int() → 0 by default.", "wrong": "❌ Use defaultdict(int)." } }
    ],
    "hard": [
      { "id": "w5-h-01", "type": "puzzle", "topic": "sorting", "question": "Order lines to sort dict items by value desc:", "choices": ["items = d.items()", "pairs = sorted(items, key=lambda kv: kv[1], reverse=True)", "print(pairs)"], "answer": ["items = d.items()", "pairs = sorted(items, key=lambda kv: kv[1], reverse=True)", "print(pairs)"], "feedback": { "correct": "✅ Sort by kv[1] with reverse=True.", "wrong": "❌ Build items, then sort." } },
      { "id": "w5-h-02", "type": "debug", "topic": "copy", "question": "Why does changing B[0][0] affect A?\n\nA = [[1,2],[3]]\nB = A.copy()\nB[0][0] = 9", "options": ["Because of deep copy", "Because of aliasing inner lists (shallow copy)", "Because tuples are used"], "answer": "Because of aliasing inner lists (shallow copy)", "feedback": { "correct": "✅ Shallow copy shares inner lists.", "wrong": "❌ Need deepcopy to isolate nested elements." } },
      { "id": "w5-h-03", "type": "fill", "topic": "hashing", "question": "Make a set of unique pairs from list Pairs allowing duplicates:", "answer": "unique = set(Pairs)", "feedback": { "correct": "✅ Tuples are hashable → set dedups.", "wrong": "❌ Ensure elements are tuples, not lists." } },
      { "id": "w5-h-04", "type": "mcq", "topic": "defaultdict", "question": "Build adjacency list graph from edges using defaultdict(list). Which line connects u→v?", "options": ["g[u] = v", "g[u].append(v)", "g.setdefault(u, v)"], "answer": "g[u].append(v)", "feedback": { "correct": "✅ Append to the list at key u.", "wrong": "❌ setdefault returns a list but you still append." } },
      { "id": "w5-h-05", "type": "fill", "topic": "counter", "question": "Get two most common from Counter c:", "answer": "c.most_common(2)", "feedback": { "correct": "✅ most_common(k).", "wrong": "❌ Use the method, not slicing." } },
      { "id": "w5-h-06", "type": "puzzle", "topic": "heap", "question": "Order lines to push 3 numbers then pop smallest:", "choices": ["import heapq", "h=[]", "heapq.heappush(h, 5)", "heapq.heappush(h, 2)", "heapq.heappush(h, 7)", "print(heapq.heappop(h))"], "answer": ["import heapq", "h=[]", "heapq.heappush(h, 5)", "heapq.heappush(h, 2)", "heapq.heappush(h, 7)", "print(heapq.heappop(h))"], "feedback": { "correct": "✅ heappop returns 2.", "wrong": "❌ Import and init before ops." } },
      { "id": "w5-h-07", "type": "debug", "topic": "dict_views", "question": "Why does iterating d.keys() reflect new keys added mid-loop?", "options": ["Because it's a static list", "Because views are dynamic", "Because dict copies on write"], "answer": "Because views are dynamic", "feedback": { "correct": "✅ Views reflect live changes.", "wrong": "❌ list(d.keys()) would be static." } },
      { "id": "w5-h-08", "type": "fill", "topic": "deque", "question": "Rotate deque q two steps to the right:", "answer": "q.rotate(2)", "feedback": { "correct": "✅ rotate moves elements cyclically.", "wrong": "❌ Use deque.rotate(k)." } },
      { "id": "w5-h-09", "type": "mcq", "topic": "nested", "question": "Safest way to read nested key 'a'→'b' with default 0:", "options": ["d['a']['b']", "d.get('a',{}).get('b',0)", "d.setdefault('a',{}).setdefault('b',0) and then read"], "answer": "d.get('a',{}).get('b',0)", "feedback": { "correct": "✅ Safe chained gets.", "wrong": "❌ setdefault mutates unintentionally." } },
      { "id": "w5-h-10", "type": "truefalse", "topic": "order", "question": "Merging dicts with d|e (3.9+) preserves left-to-right key override order.", "answer": "True", "feedback": { "correct": "✅ Right side wins on conflicts.", "wrong": "❌ That's how | merge works." } }
    ]
  }
}
